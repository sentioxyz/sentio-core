// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.33.5
// source: service/processor/protos/processor_service.proto

package protos

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	protos "sentioxyz/sentio-core/service/common/protos"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ProcessorService_GetProcessors_FullMethodName                = "/processor_service.ProcessorService/GetProcessors"
	ProcessorService_GetProcessor_FullMethodName                 = "/processor_service.ProcessorService/GetProcessor"
	ProcessorService_GetProcessorWithProject_FullMethodName      = "/processor_service.ProcessorService/GetProcessorWithProject"
	ProcessorService_GetProjectVariables_FullMethodName          = "/processor_service.ProcessorService/GetProjectVariables"
	ProcessorService_SetProcessorEntitySchema_FullMethodName     = "/processor_service.ProcessorService/SetProcessorEntitySchema"
	ProcessorService_UpdateChainProcessorStatus_FullMethodName   = "/processor_service.ProcessorService/UpdateChainProcessorStatus"
	ProcessorService_DownloadProcessor_FullMethodName            = "/processor_service.ProcessorService/DownloadProcessor"
	ProcessorService_GetProcessorStatusInternal_FullMethodName   = "/processor_service.ProcessorService/GetProcessorStatusInternal"
	ProcessorService_PauseProcessorInternal_FullMethodName       = "/processor_service.ProcessorService/PauseProcessorInternal"
	ProcessorService_GetProcessorStatusV2_FullMethodName         = "/processor_service.ProcessorService/GetProcessorStatusV2"
	ProcessorService_RemoveProcessor_FullMethodName              = "/processor_service.ProcessorService/RemoveProcessor"
	ProcessorService_GetProcessorUpgradeHistories_FullMethodName = "/processor_service.ProcessorService/GetProcessorUpgradeHistories"
	ProcessorService_PauseProcessor_FullMethodName               = "/processor_service.ProcessorService/PauseProcessor"
	ProcessorService_ResumeProcessor_FullMethodName              = "/processor_service.ProcessorService/ResumeProcessor"
	ProcessorService_SetVersionActive_FullMethodName             = "/processor_service.ProcessorService/SetVersionActive"
	ProcessorService_ActivatePendingVersion_FullMethodName       = "/processor_service.ProcessorService/ActivatePendingVersion"
	ProcessorService_RestartProcessor_FullMethodName             = "/processor_service.ProcessorService/RestartProcessor"
	ProcessorService_InitUpload_FullMethodName                   = "/processor_service.ProcessorService/InitUpload"
	ProcessorService_FinishUpload_FullMethodName                 = "/processor_service.ProcessorService/FinishUpload"
	ProcessorService_InitBatchUpload_FullMethodName              = "/processor_service.ProcessorService/InitBatchUpload"
	ProcessorService_FinishBatchUpload_FullMethodName            = "/processor_service.ProcessorService/FinishBatchUpload"
)

// ProcessorServiceClient is the client API for ProcessorService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProcessorServiceClient interface {
	GetProcessors(ctx context.Context, in *GetProcessorsRequest, opts ...grpc.CallOption) (*GetProcessorsResponse, error)
	GetProcessor(ctx context.Context, in *GetProcessorRequest, opts ...grpc.CallOption) (*GetProcessorResponse, error)
	GetProcessorWithProject(ctx context.Context, in *GetProcessorRequest, opts ...grpc.CallOption) (*GetProcessorWithProjectResponse, error)
	GetProjectVariables(ctx context.Context, in *GetProjectVariablesRequest, opts ...grpc.CallOption) (*protos.ProjectVariables, error)
	SetProcessorEntitySchema(ctx context.Context, in *SetProcessorEntitySchemaRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	UpdateChainProcessorStatus(ctx context.Context, in *UpdateChainProcessorStatusRequest, opts ...grpc.CallOption) (*UpdateChainProcessorStatusResponse, error)
	DownloadProcessor(ctx context.Context, in *DownloadProcessorRequest, opts ...grpc.CallOption) (*DownloadProcessorResponse, error)
	GetProcessorStatusInternal(ctx context.Context, in *GetProcessorStatusRequest, opts ...grpc.CallOption) (*GetProcessorStatusResponse, error)
	PauseProcessorInternal(ctx context.Context, in *PauseProcessorRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetProcessorStatusV2(ctx context.Context, in *GetProcessorStatusRequestV2, opts ...grpc.CallOption) (*GetProcessorStatusResponse, error)
	RemoveProcessor(ctx context.Context, in *ProcessorIdRequest, opts ...grpc.CallOption) (*RemoveProcessorResponse, error)
	GetProcessorUpgradeHistories(ctx context.Context, in *GetProcessorUpgradeHistoryRequest, opts ...grpc.CallOption) (*GetProcessorUpgradeHistoryResponse, error)
	PauseProcessor(ctx context.Context, in *PauseProcessorRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ResumeProcessor(ctx context.Context, in *GetProcessorRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	SetVersionActive(ctx context.Context, in *GetProcessorRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ActivatePendingVersion(ctx context.Context, in *ActivatePendingRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RestartProcessor(ctx context.Context, in *GetProcessorRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	InitUpload(ctx context.Context, in *InitUploadRequest, opts ...grpc.CallOption) (*InitUploadResponse, error)
	FinishUpload(ctx context.Context, in *FinishUploadRequest, opts ...grpc.CallOption) (*FinishUploadResponse, error)
	InitBatchUpload(ctx context.Context, in *InitBatchUploadRequest, opts ...grpc.CallOption) (*InitBatchUploadResponse, error)
	FinishBatchUpload(ctx context.Context, in *FinishBatchUploadRequest, opts ...grpc.CallOption) (*FinishBatchUploadResponse, error)
}

type processorServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewProcessorServiceClient(cc grpc.ClientConnInterface) ProcessorServiceClient {
	return &processorServiceClient{cc}
}

func (c *processorServiceClient) GetProcessors(ctx context.Context, in *GetProcessorsRequest, opts ...grpc.CallOption) (*GetProcessorsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProcessorsResponse)
	err := c.cc.Invoke(ctx, ProcessorService_GetProcessors_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processorServiceClient) GetProcessor(ctx context.Context, in *GetProcessorRequest, opts ...grpc.CallOption) (*GetProcessorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProcessorResponse)
	err := c.cc.Invoke(ctx, ProcessorService_GetProcessor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processorServiceClient) GetProcessorWithProject(ctx context.Context, in *GetProcessorRequest, opts ...grpc.CallOption) (*GetProcessorWithProjectResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProcessorWithProjectResponse)
	err := c.cc.Invoke(ctx, ProcessorService_GetProcessorWithProject_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processorServiceClient) GetProjectVariables(ctx context.Context, in *GetProjectVariablesRequest, opts ...grpc.CallOption) (*protos.ProjectVariables, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(protos.ProjectVariables)
	err := c.cc.Invoke(ctx, ProcessorService_GetProjectVariables_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processorServiceClient) SetProcessorEntitySchema(ctx context.Context, in *SetProcessorEntitySchemaRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ProcessorService_SetProcessorEntitySchema_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processorServiceClient) UpdateChainProcessorStatus(ctx context.Context, in *UpdateChainProcessorStatusRequest, opts ...grpc.CallOption) (*UpdateChainProcessorStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateChainProcessorStatusResponse)
	err := c.cc.Invoke(ctx, ProcessorService_UpdateChainProcessorStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processorServiceClient) DownloadProcessor(ctx context.Context, in *DownloadProcessorRequest, opts ...grpc.CallOption) (*DownloadProcessorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DownloadProcessorResponse)
	err := c.cc.Invoke(ctx, ProcessorService_DownloadProcessor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processorServiceClient) GetProcessorStatusInternal(ctx context.Context, in *GetProcessorStatusRequest, opts ...grpc.CallOption) (*GetProcessorStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProcessorStatusResponse)
	err := c.cc.Invoke(ctx, ProcessorService_GetProcessorStatusInternal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processorServiceClient) PauseProcessorInternal(ctx context.Context, in *PauseProcessorRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ProcessorService_PauseProcessorInternal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processorServiceClient) GetProcessorStatusV2(ctx context.Context, in *GetProcessorStatusRequestV2, opts ...grpc.CallOption) (*GetProcessorStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProcessorStatusResponse)
	err := c.cc.Invoke(ctx, ProcessorService_GetProcessorStatusV2_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processorServiceClient) RemoveProcessor(ctx context.Context, in *ProcessorIdRequest, opts ...grpc.CallOption) (*RemoveProcessorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemoveProcessorResponse)
	err := c.cc.Invoke(ctx, ProcessorService_RemoveProcessor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processorServiceClient) GetProcessorUpgradeHistories(ctx context.Context, in *GetProcessorUpgradeHistoryRequest, opts ...grpc.CallOption) (*GetProcessorUpgradeHistoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProcessorUpgradeHistoryResponse)
	err := c.cc.Invoke(ctx, ProcessorService_GetProcessorUpgradeHistories_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processorServiceClient) PauseProcessor(ctx context.Context, in *PauseProcessorRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ProcessorService_PauseProcessor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processorServiceClient) ResumeProcessor(ctx context.Context, in *GetProcessorRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ProcessorService_ResumeProcessor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processorServiceClient) SetVersionActive(ctx context.Context, in *GetProcessorRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ProcessorService_SetVersionActive_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processorServiceClient) ActivatePendingVersion(ctx context.Context, in *ActivatePendingRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ProcessorService_ActivatePendingVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processorServiceClient) RestartProcessor(ctx context.Context, in *GetProcessorRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ProcessorService_RestartProcessor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processorServiceClient) InitUpload(ctx context.Context, in *InitUploadRequest, opts ...grpc.CallOption) (*InitUploadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InitUploadResponse)
	err := c.cc.Invoke(ctx, ProcessorService_InitUpload_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processorServiceClient) FinishUpload(ctx context.Context, in *FinishUploadRequest, opts ...grpc.CallOption) (*FinishUploadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FinishUploadResponse)
	err := c.cc.Invoke(ctx, ProcessorService_FinishUpload_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processorServiceClient) InitBatchUpload(ctx context.Context, in *InitBatchUploadRequest, opts ...grpc.CallOption) (*InitBatchUploadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InitBatchUploadResponse)
	err := c.cc.Invoke(ctx, ProcessorService_InitBatchUpload_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processorServiceClient) FinishBatchUpload(ctx context.Context, in *FinishBatchUploadRequest, opts ...grpc.CallOption) (*FinishBatchUploadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FinishBatchUploadResponse)
	err := c.cc.Invoke(ctx, ProcessorService_FinishBatchUpload_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProcessorServiceServer is the server API for ProcessorService service.
// All implementations must embed UnimplementedProcessorServiceServer
// for forward compatibility.
type ProcessorServiceServer interface {
	GetProcessors(context.Context, *GetProcessorsRequest) (*GetProcessorsResponse, error)
	GetProcessor(context.Context, *GetProcessorRequest) (*GetProcessorResponse, error)
	GetProcessorWithProject(context.Context, *GetProcessorRequest) (*GetProcessorWithProjectResponse, error)
	GetProjectVariables(context.Context, *GetProjectVariablesRequest) (*protos.ProjectVariables, error)
	SetProcessorEntitySchema(context.Context, *SetProcessorEntitySchemaRequest) (*emptypb.Empty, error)
	UpdateChainProcessorStatus(context.Context, *UpdateChainProcessorStatusRequest) (*UpdateChainProcessorStatusResponse, error)
	DownloadProcessor(context.Context, *DownloadProcessorRequest) (*DownloadProcessorResponse, error)
	GetProcessorStatusInternal(context.Context, *GetProcessorStatusRequest) (*GetProcessorStatusResponse, error)
	PauseProcessorInternal(context.Context, *PauseProcessorRequest) (*emptypb.Empty, error)
	GetProcessorStatusV2(context.Context, *GetProcessorStatusRequestV2) (*GetProcessorStatusResponse, error)
	RemoveProcessor(context.Context, *ProcessorIdRequest) (*RemoveProcessorResponse, error)
	GetProcessorUpgradeHistories(context.Context, *GetProcessorUpgradeHistoryRequest) (*GetProcessorUpgradeHistoryResponse, error)
	PauseProcessor(context.Context, *PauseProcessorRequest) (*emptypb.Empty, error)
	ResumeProcessor(context.Context, *GetProcessorRequest) (*emptypb.Empty, error)
	SetVersionActive(context.Context, *GetProcessorRequest) (*emptypb.Empty, error)
	ActivatePendingVersion(context.Context, *ActivatePendingRequest) (*emptypb.Empty, error)
	RestartProcessor(context.Context, *GetProcessorRequest) (*emptypb.Empty, error)
	InitUpload(context.Context, *InitUploadRequest) (*InitUploadResponse, error)
	FinishUpload(context.Context, *FinishUploadRequest) (*FinishUploadResponse, error)
	InitBatchUpload(context.Context, *InitBatchUploadRequest) (*InitBatchUploadResponse, error)
	FinishBatchUpload(context.Context, *FinishBatchUploadRequest) (*FinishBatchUploadResponse, error)
	mustEmbedUnimplementedProcessorServiceServer()
}

// UnimplementedProcessorServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedProcessorServiceServer struct{}

func (UnimplementedProcessorServiceServer) GetProcessors(context.Context, *GetProcessorsRequest) (*GetProcessorsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProcessors not implemented")
}
func (UnimplementedProcessorServiceServer) GetProcessor(context.Context, *GetProcessorRequest) (*GetProcessorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProcessor not implemented")
}
func (UnimplementedProcessorServiceServer) GetProcessorWithProject(context.Context, *GetProcessorRequest) (*GetProcessorWithProjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProcessorWithProject not implemented")
}
func (UnimplementedProcessorServiceServer) GetProjectVariables(context.Context, *GetProjectVariablesRequest) (*protos.ProjectVariables, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProjectVariables not implemented")
}
func (UnimplementedProcessorServiceServer) SetProcessorEntitySchema(context.Context, *SetProcessorEntitySchemaRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetProcessorEntitySchema not implemented")
}
func (UnimplementedProcessorServiceServer) UpdateChainProcessorStatus(context.Context, *UpdateChainProcessorStatusRequest) (*UpdateChainProcessorStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateChainProcessorStatus not implemented")
}
func (UnimplementedProcessorServiceServer) DownloadProcessor(context.Context, *DownloadProcessorRequest) (*DownloadProcessorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownloadProcessor not implemented")
}
func (UnimplementedProcessorServiceServer) GetProcessorStatusInternal(context.Context, *GetProcessorStatusRequest) (*GetProcessorStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProcessorStatusInternal not implemented")
}
func (UnimplementedProcessorServiceServer) PauseProcessorInternal(context.Context, *PauseProcessorRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PauseProcessorInternal not implemented")
}
func (UnimplementedProcessorServiceServer) GetProcessorStatusV2(context.Context, *GetProcessorStatusRequestV2) (*GetProcessorStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProcessorStatusV2 not implemented")
}
func (UnimplementedProcessorServiceServer) RemoveProcessor(context.Context, *ProcessorIdRequest) (*RemoveProcessorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveProcessor not implemented")
}
func (UnimplementedProcessorServiceServer) GetProcessorUpgradeHistories(context.Context, *GetProcessorUpgradeHistoryRequest) (*GetProcessorUpgradeHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProcessorUpgradeHistories not implemented")
}
func (UnimplementedProcessorServiceServer) PauseProcessor(context.Context, *PauseProcessorRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PauseProcessor not implemented")
}
func (UnimplementedProcessorServiceServer) ResumeProcessor(context.Context, *GetProcessorRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResumeProcessor not implemented")
}
func (UnimplementedProcessorServiceServer) SetVersionActive(context.Context, *GetProcessorRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetVersionActive not implemented")
}
func (UnimplementedProcessorServiceServer) ActivatePendingVersion(context.Context, *ActivatePendingRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActivatePendingVersion not implemented")
}
func (UnimplementedProcessorServiceServer) RestartProcessor(context.Context, *GetProcessorRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RestartProcessor not implemented")
}
func (UnimplementedProcessorServiceServer) InitUpload(context.Context, *InitUploadRequest) (*InitUploadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitUpload not implemented")
}
func (UnimplementedProcessorServiceServer) FinishUpload(context.Context, *FinishUploadRequest) (*FinishUploadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FinishUpload not implemented")
}
func (UnimplementedProcessorServiceServer) InitBatchUpload(context.Context, *InitBatchUploadRequest) (*InitBatchUploadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitBatchUpload not implemented")
}
func (UnimplementedProcessorServiceServer) FinishBatchUpload(context.Context, *FinishBatchUploadRequest) (*FinishBatchUploadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FinishBatchUpload not implemented")
}
func (UnimplementedProcessorServiceServer) mustEmbedUnimplementedProcessorServiceServer() {}
func (UnimplementedProcessorServiceServer) testEmbeddedByValue()                          {}

// UnsafeProcessorServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProcessorServiceServer will
// result in compilation errors.
type UnsafeProcessorServiceServer interface {
	mustEmbedUnimplementedProcessorServiceServer()
}

func RegisterProcessorServiceServer(s grpc.ServiceRegistrar, srv ProcessorServiceServer) {
	// If the following call pancis, it indicates UnimplementedProcessorServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ProcessorService_ServiceDesc, srv)
}

func _ProcessorService_GetProcessors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProcessorsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessorServiceServer).GetProcessors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcessorService_GetProcessors_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessorServiceServer).GetProcessors(ctx, req.(*GetProcessorsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessorService_GetProcessor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProcessorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessorServiceServer).GetProcessor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcessorService_GetProcessor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessorServiceServer).GetProcessor(ctx, req.(*GetProcessorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessorService_GetProcessorWithProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProcessorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessorServiceServer).GetProcessorWithProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcessorService_GetProcessorWithProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessorServiceServer).GetProcessorWithProject(ctx, req.(*GetProcessorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessorService_GetProjectVariables_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProjectVariablesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessorServiceServer).GetProjectVariables(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcessorService_GetProjectVariables_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessorServiceServer).GetProjectVariables(ctx, req.(*GetProjectVariablesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessorService_SetProcessorEntitySchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetProcessorEntitySchemaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessorServiceServer).SetProcessorEntitySchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcessorService_SetProcessorEntitySchema_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessorServiceServer).SetProcessorEntitySchema(ctx, req.(*SetProcessorEntitySchemaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessorService_UpdateChainProcessorStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateChainProcessorStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessorServiceServer).UpdateChainProcessorStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcessorService_UpdateChainProcessorStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessorServiceServer).UpdateChainProcessorStatus(ctx, req.(*UpdateChainProcessorStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessorService_DownloadProcessor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DownloadProcessorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessorServiceServer).DownloadProcessor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcessorService_DownloadProcessor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessorServiceServer).DownloadProcessor(ctx, req.(*DownloadProcessorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessorService_GetProcessorStatusInternal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProcessorStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessorServiceServer).GetProcessorStatusInternal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcessorService_GetProcessorStatusInternal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessorServiceServer).GetProcessorStatusInternal(ctx, req.(*GetProcessorStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessorService_PauseProcessorInternal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PauseProcessorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessorServiceServer).PauseProcessorInternal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcessorService_PauseProcessorInternal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessorServiceServer).PauseProcessorInternal(ctx, req.(*PauseProcessorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessorService_GetProcessorStatusV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProcessorStatusRequestV2)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessorServiceServer).GetProcessorStatusV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcessorService_GetProcessorStatusV2_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessorServiceServer).GetProcessorStatusV2(ctx, req.(*GetProcessorStatusRequestV2))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessorService_RemoveProcessor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessorIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessorServiceServer).RemoveProcessor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcessorService_RemoveProcessor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessorServiceServer).RemoveProcessor(ctx, req.(*ProcessorIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessorService_GetProcessorUpgradeHistories_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProcessorUpgradeHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessorServiceServer).GetProcessorUpgradeHistories(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcessorService_GetProcessorUpgradeHistories_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessorServiceServer).GetProcessorUpgradeHistories(ctx, req.(*GetProcessorUpgradeHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessorService_PauseProcessor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PauseProcessorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessorServiceServer).PauseProcessor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcessorService_PauseProcessor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessorServiceServer).PauseProcessor(ctx, req.(*PauseProcessorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessorService_ResumeProcessor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProcessorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessorServiceServer).ResumeProcessor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcessorService_ResumeProcessor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessorServiceServer).ResumeProcessor(ctx, req.(*GetProcessorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessorService_SetVersionActive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProcessorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessorServiceServer).SetVersionActive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcessorService_SetVersionActive_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessorServiceServer).SetVersionActive(ctx, req.(*GetProcessorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessorService_ActivatePendingVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActivatePendingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessorServiceServer).ActivatePendingVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcessorService_ActivatePendingVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessorServiceServer).ActivatePendingVersion(ctx, req.(*ActivatePendingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessorService_RestartProcessor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProcessorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessorServiceServer).RestartProcessor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcessorService_RestartProcessor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessorServiceServer).RestartProcessor(ctx, req.(*GetProcessorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessorService_InitUpload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitUploadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessorServiceServer).InitUpload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcessorService_InitUpload_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessorServiceServer).InitUpload(ctx, req.(*InitUploadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessorService_FinishUpload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FinishUploadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessorServiceServer).FinishUpload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcessorService_FinishUpload_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessorServiceServer).FinishUpload(ctx, req.(*FinishUploadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessorService_InitBatchUpload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitBatchUploadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessorServiceServer).InitBatchUpload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcessorService_InitBatchUpload_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessorServiceServer).InitBatchUpload(ctx, req.(*InitBatchUploadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessorService_FinishBatchUpload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FinishBatchUploadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessorServiceServer).FinishBatchUpload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcessorService_FinishBatchUpload_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessorServiceServer).FinishBatchUpload(ctx, req.(*FinishBatchUploadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ProcessorService_ServiceDesc is the grpc.ServiceDesc for ProcessorService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProcessorService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "processor_service.ProcessorService",
	HandlerType: (*ProcessorServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetProcessors",
			Handler:    _ProcessorService_GetProcessors_Handler,
		},
		{
			MethodName: "GetProcessor",
			Handler:    _ProcessorService_GetProcessor_Handler,
		},
		{
			MethodName: "GetProcessorWithProject",
			Handler:    _ProcessorService_GetProcessorWithProject_Handler,
		},
		{
			MethodName: "GetProjectVariables",
			Handler:    _ProcessorService_GetProjectVariables_Handler,
		},
		{
			MethodName: "SetProcessorEntitySchema",
			Handler:    _ProcessorService_SetProcessorEntitySchema_Handler,
		},
		{
			MethodName: "UpdateChainProcessorStatus",
			Handler:    _ProcessorService_UpdateChainProcessorStatus_Handler,
		},
		{
			MethodName: "DownloadProcessor",
			Handler:    _ProcessorService_DownloadProcessor_Handler,
		},
		{
			MethodName: "GetProcessorStatusInternal",
			Handler:    _ProcessorService_GetProcessorStatusInternal_Handler,
		},
		{
			MethodName: "PauseProcessorInternal",
			Handler:    _ProcessorService_PauseProcessorInternal_Handler,
		},
		{
			MethodName: "GetProcessorStatusV2",
			Handler:    _ProcessorService_GetProcessorStatusV2_Handler,
		},
		{
			MethodName: "RemoveProcessor",
			Handler:    _ProcessorService_RemoveProcessor_Handler,
		},
		{
			MethodName: "GetProcessorUpgradeHistories",
			Handler:    _ProcessorService_GetProcessorUpgradeHistories_Handler,
		},
		{
			MethodName: "PauseProcessor",
			Handler:    _ProcessorService_PauseProcessor_Handler,
		},
		{
			MethodName: "ResumeProcessor",
			Handler:    _ProcessorService_ResumeProcessor_Handler,
		},
		{
			MethodName: "SetVersionActive",
			Handler:    _ProcessorService_SetVersionActive_Handler,
		},
		{
			MethodName: "ActivatePendingVersion",
			Handler:    _ProcessorService_ActivatePendingVersion_Handler,
		},
		{
			MethodName: "RestartProcessor",
			Handler:    _ProcessorService_RestartProcessor_Handler,
		},
		{
			MethodName: "InitUpload",
			Handler:    _ProcessorService_InitUpload_Handler,
		},
		{
			MethodName: "FinishUpload",
			Handler:    _ProcessorService_FinishUpload_Handler,
		},
		{
			MethodName: "InitBatchUpload",
			Handler:    _ProcessorService_InitBatchUpload_Handler,
		},
		{
			MethodName: "FinishBatchUpload",
			Handler:    _ProcessorService_FinishBatchUpload_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service/processor/protos/processor_service.proto",
}

const (
	ProcessorRuntimeService_RunProcessor_FullMethodName       = "/processor_service.ProcessorRuntimeService/RunProcessor"
	ProcessorRuntimeService_StopProcessor_FullMethodName      = "/processor_service.ProcessorRuntimeService/StopProcessor"
	ProcessorRuntimeService_GetProcessorStatus_FullMethodName = "/processor_service.ProcessorRuntimeService/GetProcessorStatus"
	ProcessorRuntimeService_GetLogs_FullMethodName            = "/processor_service.ProcessorRuntimeService/GetLogs"
)

// ProcessorRuntimeServiceClient is the client API for ProcessorRuntimeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProcessorRuntimeServiceClient interface {
	RunProcessor(ctx context.Context, in *RunProcessorRequest, opts ...grpc.CallOption) (*Processor, error)
	StopProcessor(ctx context.Context, in *StopProcessorRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetProcessorStatus(ctx context.Context, in *GetProcessorStatusRequest, opts ...grpc.CallOption) (*GetProcessorStatusResponse, error)
	GetLogs(ctx context.Context, in *GetLogsRequest, opts ...grpc.CallOption) (*GetLogsResponse, error)
}

type processorRuntimeServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewProcessorRuntimeServiceClient(cc grpc.ClientConnInterface) ProcessorRuntimeServiceClient {
	return &processorRuntimeServiceClient{cc}
}

func (c *processorRuntimeServiceClient) RunProcessor(ctx context.Context, in *RunProcessorRequest, opts ...grpc.CallOption) (*Processor, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Processor)
	err := c.cc.Invoke(ctx, ProcessorRuntimeService_RunProcessor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processorRuntimeServiceClient) StopProcessor(ctx context.Context, in *StopProcessorRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ProcessorRuntimeService_StopProcessor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processorRuntimeServiceClient) GetProcessorStatus(ctx context.Context, in *GetProcessorStatusRequest, opts ...grpc.CallOption) (*GetProcessorStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProcessorStatusResponse)
	err := c.cc.Invoke(ctx, ProcessorRuntimeService_GetProcessorStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processorRuntimeServiceClient) GetLogs(ctx context.Context, in *GetLogsRequest, opts ...grpc.CallOption) (*GetLogsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLogsResponse)
	err := c.cc.Invoke(ctx, ProcessorRuntimeService_GetLogs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProcessorRuntimeServiceServer is the server API for ProcessorRuntimeService service.
// All implementations must embed UnimplementedProcessorRuntimeServiceServer
// for forward compatibility.
type ProcessorRuntimeServiceServer interface {
	RunProcessor(context.Context, *RunProcessorRequest) (*Processor, error)
	StopProcessor(context.Context, *StopProcessorRequest) (*emptypb.Empty, error)
	GetProcessorStatus(context.Context, *GetProcessorStatusRequest) (*GetProcessorStatusResponse, error)
	GetLogs(context.Context, *GetLogsRequest) (*GetLogsResponse, error)
	mustEmbedUnimplementedProcessorRuntimeServiceServer()
}

// UnimplementedProcessorRuntimeServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedProcessorRuntimeServiceServer struct{}

func (UnimplementedProcessorRuntimeServiceServer) RunProcessor(context.Context, *RunProcessorRequest) (*Processor, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunProcessor not implemented")
}
func (UnimplementedProcessorRuntimeServiceServer) StopProcessor(context.Context, *StopProcessorRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopProcessor not implemented")
}
func (UnimplementedProcessorRuntimeServiceServer) GetProcessorStatus(context.Context, *GetProcessorStatusRequest) (*GetProcessorStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProcessorStatus not implemented")
}
func (UnimplementedProcessorRuntimeServiceServer) GetLogs(context.Context, *GetLogsRequest) (*GetLogsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLogs not implemented")
}
func (UnimplementedProcessorRuntimeServiceServer) mustEmbedUnimplementedProcessorRuntimeServiceServer() {
}
func (UnimplementedProcessorRuntimeServiceServer) testEmbeddedByValue() {}

// UnsafeProcessorRuntimeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProcessorRuntimeServiceServer will
// result in compilation errors.
type UnsafeProcessorRuntimeServiceServer interface {
	mustEmbedUnimplementedProcessorRuntimeServiceServer()
}

func RegisterProcessorRuntimeServiceServer(s grpc.ServiceRegistrar, srv ProcessorRuntimeServiceServer) {
	// If the following call pancis, it indicates UnimplementedProcessorRuntimeServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ProcessorRuntimeService_ServiceDesc, srv)
}

func _ProcessorRuntimeService_RunProcessor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunProcessorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessorRuntimeServiceServer).RunProcessor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcessorRuntimeService_RunProcessor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessorRuntimeServiceServer).RunProcessor(ctx, req.(*RunProcessorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessorRuntimeService_StopProcessor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopProcessorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessorRuntimeServiceServer).StopProcessor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcessorRuntimeService_StopProcessor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessorRuntimeServiceServer).StopProcessor(ctx, req.(*StopProcessorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessorRuntimeService_GetProcessorStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProcessorStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessorRuntimeServiceServer).GetProcessorStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcessorRuntimeService_GetProcessorStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessorRuntimeServiceServer).GetProcessorStatus(ctx, req.(*GetProcessorStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessorRuntimeService_GetLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessorRuntimeServiceServer).GetLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcessorRuntimeService_GetLogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessorRuntimeServiceServer).GetLogs(ctx, req.(*GetLogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ProcessorRuntimeService_ServiceDesc is the grpc.ServiceDesc for ProcessorRuntimeService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProcessorRuntimeService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "processor_service.ProcessorRuntimeService",
	HandlerType: (*ProcessorRuntimeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RunProcessor",
			Handler:    _ProcessorRuntimeService_RunProcessor_Handler,
		},
		{
			MethodName: "StopProcessor",
			Handler:    _ProcessorRuntimeService_StopProcessor_Handler,
		},
		{
			MethodName: "GetProcessorStatus",
			Handler:    _ProcessorRuntimeService_GetProcessorStatus_Handler,
		},
		{
			MethodName: "GetLogs",
			Handler:    _ProcessorRuntimeService_GetLogs_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service/processor/protos/processor_service.proto",
}
